#ifndef MISSILE_CONTROLLER_H
#define MISSILE_CONTROLLER_H

#include <vector>
#include <algorithm>
#include "missile.h"
#include "detection_system.h"

class MissileController
{
public:
    void addMissile(const Missile &missile);
    void moveAllMissiles(double dx, double dy, double dz);
    void printAllStatuses() const;
    void launchMissile(Missile &missile, const Position &target);
    Missile *getMissileById(int id);
    bool removeMissileById(int id);
    void detectIncomingMissiles();
    int interceptThreat(const ThreatReport& threat);
    
    // Auto-intercept functionality
    void setAutoIntercept(bool enabled);
    bool isAutoInterceptEnabled() const;
    void setAutoInterceptThreshold(double threshold);
    void setMaxAutoInterceptMissiles(int maxMissiles);
    std::vector<int> autoInterceptThreats(const std::vector<ThreatReport>& threats);
    void printAutoInterceptStatus() const;
    
    // Utility methods for auto-intercept
    int getAvailableMissileCount() const;
    bool hasAvailableMissiles() const;

private:
    std::vector<Missile> missiles;
    
    // Auto-intercept settings
    bool autoInterceptEnabled = false;
    double autoInterceptThreshold = 2000.0;  // Only auto-intercept if threat is within this distance (km)
    int maxAutoInterceptMissiles = 3;        // Maximum missiles to use for auto-intercept
    int usedAutoInterceptMissiles = 0;       // Track how many we've used this session
    
    // Helper methods
    std::vector<ThreatReport> prioritizeThreats(const std::vector<ThreatReport>& threats) const;
    bool shouldInterceptThreat(const ThreatReport& threat) const;
    Missile* selectBestInterceptor(const ThreatReport& threat);
};

#endif#ifndef DETECTION_SYSTEM_H
#define DETECTION_SYSTEM_H

#include <vector>
#include <string>
#include <cmath>
#include "position.h"
#include "enemy_missile.h"
#include "target.h"

struct ThreatReport
{
        int detectionId;
        int enemyId;
        std::string enemyName;
        std::string targetName;
        double distanceToTarget;
        double calculatedSpeed;
        Position enemyPosition; //
};

class DetectionSystem
{
public:
        DetectionSystem(const std::vector<EnemyMissile> &enemyMissiles, const std::vector<Target> &targets);
        std::vector<ThreatReport> scanForThreats();

private:
        const std::vector<EnemyMissile> &enemyMissiles;
        const std::vector<Target> &targets;
        int detectionIdCounter;
};

#endif#ifndef TARGET_H
#define TARGET_H

#include <string>
#include "position.h" // The Target struct needs to know about Position

struct Target
{
    std::string name;
    Position position;
};

#endif // TARGET_H#ifndef ENEMY_MISSILE_H // <<< The gate is closed if this hasn't been defined
#define ENEMY_MISSILE_H // <<< Define the gate
#include "position.h" // <<< Include the new position header

class EnemyMissile
{
public:
    EnemyMissile(int id, const Position &start, const Position &target, double speed);
    void move(); // A method to move the missile
    const Position &getCurrentPosition() const;
    int getId() const;
    const Position &getTargetPosition() const;
    double getSpeed() const;

private:
    int id;
    Position currentPosition;
    Position targetPosition;
    double speed;
    Position startPosition;
};
#endif // ENEMY_MISSILE_H <<< End of the gate
#ifndef MISSILE_H
#define MISSILE_H

#include <string>
#include <iostream>
#include "position.h"


class Missile
{
public:

    // Corrected constructor declaration
    Missile(int id, int damage, std::string missileName, double missileSpeed, Position startPosition);
    void move(double dx, double dy, double dz);
    bool hasHitTarget() const;
    void printStatus() const;

    // --- Add these public getter methods ---
    int getId() const;
    std::string getName() const;
    double getSpeed() const;
    Position getCurrentPosition() const;

    void triggerLaunch(const Position &target);

private:
    // Private member variables (now encapsulated)
    int id;
    int damageStrength;
    std::string name;
    double speed;
    Position currentPosition;

    bool isLaunched;
};

#endif#ifndef POSITION_H
#define POSITION_H

struct Position
{
    double x;
    double y;
    double z;
};

#endif #include "missile_controller.h"
#include <iostream>
#include <algorithm>

#define RESET "\033[0m"
#define BOLD "\033[1m"
#define GREEN "\033[32m"
#define YELLOW "\033[33m"
#define CYAN "\033[36m"
#define RED "\033[31m"
#define MAGENTA "\033[35m"

// Existing methods (keeping your current implementations)
void MissileController::addMissile(const Missile &missile)
{
    missiles.push_back(missile);
}

void MissileController::moveAllMissiles(double dx, double dy, double dz)
{
    for (auto &missile : missiles)
    {
        missile.move(dx, dy, dz);
    }
}

void MissileController::printAllStatuses() const
{
    std::cout << "\n";
    for (const auto &missile : missiles)
    {
        missile.printStatus();
    }
}

void MissileController::launchMissile(Missile &missile, const Position &targetCity)
{
    std::cout << "\n";
    int missileId = missile.getId();
    std::string missileName = missile.getName();

    std::cout << "\033[1;33m-- Launching " << missileName << " Missile --\033[0m" << std::endl;
    std::cout << "\033[36m  - Speed: " << missile.getSpeed() << " m/s" << std::endl;
    std::cout << "  - From: (" << missile.getCurrentPosition().x << ", "
              << missile.getCurrentPosition().y << ", " << missile.getCurrentPosition().z << ")" << std::endl;
    std::cout << "  - To:   (" << targetCity.x << ", "
              << targetCity.y << ", " << targetCity.z << ")" << std::endl;
    std::cout << "\033[0m------------------------------------------" << std::endl;

    missile.triggerLaunch(targetCity);

    if (removeMissileById(missileId))
    {
        // Missile removed successfully
    }
    else
    {
        std::cout << "\n\033[1;31mError: Failed to remove " << missileName << " (ID: #" << missileId << ").\033[0m" << std::endl;
    }
}

bool MissileController::removeMissileById(int id)
{
    for (auto it = missiles.begin(); it != missiles.end(); ++it)
    {
        if (it->getId() == id)
        {
            missiles.erase(it);
            return true;
        }
    }
    return false;
}

Missile *MissileController::getMissileById(int id)
{
    for (Missile &missile : missiles)
    {
        if (missile.getId() == id)
        {
            return &missile;
        }
    }
    return nullptr;
}

int MissileController::interceptThreat(const ThreatReport& threat) {
    if (missiles.empty()) {
        std::cout << RED << "No available missiles to launch an intercept!" << RESET << std::endl;
        return -1;
    }

    Missile& interceptorMissile = missiles.front();
    int missileId = interceptorMissile.getId();
    std::string missileName = interceptorMissile.getName();
    
    std::cout << GREEN << "Intercept started" << RESET << std::endl;
    launchMissile(interceptorMissile, threat.enemyPosition);

    return threat.enemyId;
}

// NEW AUTO-INTERCEPT METHODS

void MissileController::setAutoIntercept(bool enabled) {
    autoInterceptEnabled = enabled;
    std::cout << CYAN << "Auto-intercept " << (enabled ? "ENABLED" : "DISABLED") << RESET << std::endl;
}

bool MissileController::isAutoInterceptEnabled() const {
    return autoInterceptEnabled;
}

void MissileController::setAutoInterceptThreshold(double threshold) {
    autoInterceptThreshold = threshold;
    std::cout << CYAN << "Auto-intercept threshold set to " << threshold << " km" << RESET << std::endl;
}

void MissileController::setMaxAutoInterceptMissiles(int maxMissiles) {
    maxAutoInterceptMissiles = maxMissiles;
    std::cout << CYAN << "Max auto-intercept missiles set to " << maxMissiles << RESET << std::endl;
}

// FIXED: Updated autoInterceptThreats method
std::vector<int> MissileController::autoInterceptThreats(const std::vector<ThreatReport>& threats) {
    std::vector<int> interceptedEnemyIds;  // Track which enemies were actually intercepted
    
    if (!autoInterceptEnabled || threats.empty()) {
        return interceptedEnemyIds;
    }

    if (!hasAvailableMissiles()) {
        std::cout << YELLOW << "Auto-intercept: No missiles available" << RESET << std::endl;
        return interceptedEnemyIds;
    }

    if (usedAutoInterceptMissiles >= maxAutoInterceptMissiles) {
        std::cout << YELLOW << "Auto-intercept: Maximum auto-intercept missiles used (" 
                  << maxAutoInterceptMissiles << ")" << RESET << std::endl;
        return interceptedEnemyIds;
    }

    std::vector<ThreatReport> prioritizedThreats = prioritizeThreats(threats);

    for (const auto& threat : prioritizedThreats) {
        if (usedAutoInterceptMissiles >= maxAutoInterceptMissiles) {
            break;
        }

        if (!hasAvailableMissiles()) {
            break;
        }

        if (shouldInterceptThreat(threat)) {
            Missile* interceptor = selectBestInterceptor(threat);
            
            if (interceptor) {
                std::cout << BOLD << MAGENTA << "ðŸ¤– AUTO-INTERCEPT ENGAGED: " 
                          << "Launching " << interceptor->getName() 
                          << " against threat #" << threat.detectionId 
                          << " (Enemy ID: " << threat.enemyId << ")" << RESET << std::endl;
                
                // Launch the interceptor
                launchMissile(*interceptor, threat.enemyPosition);
                usedAutoInterceptMissiles++;
                
                // Add this enemy ID to our intercepted list
                interceptedEnemyIds.push_back(threat.enemyId);
                
                // IMPORTANT: Only intercept ONE threat per call for realistic simulation
                break;  // Exit after first intercept
            }
        }
    }

    return interceptedEnemyIds;
}
void MissileController::printAutoInterceptStatus() const {
    std::cout << CYAN << "Auto-Intercept Status:" << RESET << std::endl;
    std::cout << "  Enabled: " << (autoInterceptEnabled ? GREEN "YES" : RED "NO") << RESET << std::endl;
    std::cout << "  Threshold: " << autoInterceptThreshold << " km" << std::endl;
    std::cout << "  Missiles Used: " << usedAutoInterceptMissiles << "/" << maxAutoInterceptMissiles << std::endl;
    std::cout << "  Available Missiles: " << getAvailableMissileCount() << std::endl;
}

int MissileController::getAvailableMissileCount() const {
    return missiles.size();
}

bool MissileController::hasAvailableMissiles() const {
    return !missiles.empty();
}

// PRIVATE HELPER METHODS

std::vector<ThreatReport> MissileController::prioritizeThreats(const std::vector<ThreatReport>& threats) const {
    std::vector<ThreatReport> prioritized = threats;
    
    // Sort by distance to target (closest threats first)
    std::sort(prioritized.begin(), prioritized.end(), 
              [](const ThreatReport& a, const ThreatReport& b) {
                  return a.distanceToTarget < b.distanceToTarget;
              });
    
    return prioritized;
}

bool MissileController::shouldInterceptThreat(const ThreatReport& threat) const {
    // Only intercept if threat is within our threshold distance
    return threat.distanceToTarget <= autoInterceptThreshold;
}

Missile* MissileController::selectBestInterceptor(const ThreatReport& threat) {
    if (missiles.empty()) {
        return nullptr;
    }

    // For now, select the fastest available missile
    // You could enhance this with more sophisticated logic
    Missile* bestMissile = &missiles[0];
    
    for (auto& missile : missiles) {
        if (missile.getSpeed() > bestMissile->getSpeed()) {
            bestMissile = &missile;
        }
    }
    
    return bestMissile;
}#include "enemy_missile.h"
#include <cmath>

// Implement the constructor to initialize the member variables
EnemyMissile::EnemyMissile(int id, const Position& start, const Position& target, double speed)
    : id(id), currentPosition(start), targetPosition(target), speed(speed), startPosition(start)
{
}

void EnemyMissile::move() {
    // This is a simplified movement logic
    // You would calculate a normalized direction vector from current to target
    double dx = targetPosition.x - currentPosition.x;
    double dy = targetPosition.y - currentPosition.y;
    double dz = targetPosition.z - currentPosition.z;

    double distance = std::sqrt(dx*dx + dy*dy + dz*dz);

    if (distance > 0) {
        // Normalize the vector
        dx /= distance;
        dy /= distance;
        dz /= distance;
        
        // Move towards the target based on the missile's speed
        currentPosition.x += dx * speed;
        currentPosition.y += dy * speed;
        currentPosition.z += dz * speed;
    }
}

const Position& EnemyMissile::getCurrentPosition() const { return currentPosition; }
int EnemyMissile::getId() const { return id; }
const Position& EnemyMissile::getTargetPosition() const { return targetPosition; }
double EnemyMissile::getSpeed() const { return speed; }#include <iostream>
#include <vector>
#include <string>
#include <limits>
#include "missile_controller.h"
#include "enemy_missile.h"
#include "detection_system.h"
#include "target.h"

// Color constants for terminal output
#define RESET "\033[0m"
#define BOLD "\033[1m"
#define GREEN "\033[32m"
#define YELLOW "\033[33m"
#define CYAN "\033[36m"
#define RED "\033[31m"

// Configuration structure for missile initialization
struct MissileConfig {
    int damage;
    std::string name;
    double speed;
    Position position;
};

// Menu options enum for better code readability
enum MenuOption {
    LIST = 1,
    LAUNCH = 2,
    DETECT = 3,
    EXIT = 4
};

/**
 * Gets validated integer input from user within specified range
 * @param prompt Message to display to user
 * @param min Minimum acceptable value
 * @param max Maximum acceptable value
 * @return Valid integer within range
 */
int getChoice(const std::string& prompt, int min, int max) {
    int choice;
    while (true) {
        std::cout << prompt;
        std::cin >> choice;
        
        if (std::cin.fail() || choice < min || choice > max) {
            std::cout << RED << "Invalid option. Please enter a number between "
                      << min << " and " << max << "." << RESET << "\n";
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        } else {
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            return choice;
        }
    }
}

/**
 * Removes an enemy missile from the vector by ID
 * @param enemies Vector of enemy missiles
 * @param id ID of missile to remove
 * @return true if missile was found and removed, false otherwise
 */
bool removeEnemyMissileById(std::vector<EnemyMissile>& enemies, int id) {
    for (auto it = enemies.begin(); it != enemies.end(); ++it) {
        if (it->getId() == id) {
            enemies.erase(it);
            return true;
        }
    }
    return false;
}

/**
 * Handles the missile launch process including target selection
 * @param controller Reference to missile controller
 * @param targets Vector of available targets
 */
void handleLaunchMissile(MissileController& controller, const std::vector<Target>& targets) {
    controller.printAllStatuses();

    int missileIdToLaunch = getChoice("\nEnter the ID of the missile to launch: ", 1, 999);
    Missile* missileToLaunch = controller.getMissileById(missileIdToLaunch);

    if (missileToLaunch) {
        std::cout << "\nAvailable Targets:\n";
        for (size_t i = 0; i < targets.size(); ++i) {
            std::cout << i + 1 << ". " << targets[i].name << "\n";
        }

        int targetChoice = getChoice("\nChoose a target (by number): ", 1, targets.size());
        const Position& chosenTarget = targets[targetChoice - 1].position;
        controller.launchMissile(*missileToLaunch, chosenTarget);
    } else {
        std::cout << RED << "Missile with ID " << missileIdToLaunch << " not found." << RESET << "\n";
    }
}

/**
 * Handles threat detection and interception process
 * @param controller Reference to missile controller
 * @param enemyMissiles Vector of enemy missiles (modified by reference)
 * @param radar Reference to detection system
 */
void handleThreatDetection(MissileController& controller, 
                          std::vector<EnemyMissile>& enemyMissiles, 
                          DetectionSystem& radar) {
    std::cout << BOLD << CYAN << "Scanning for threats..." << RESET << std::endl;
    
    // Update enemy missile positions
    for (auto& enemy : enemyMissiles) {
        enemy.move();
    }

    std::vector<ThreatReport> threats = radar.scanForThreats();

    if (threats.empty()) {
        std::cout << GREEN << "No threats detected." << RESET << std::endl;
        return;
    }

    // Display detected threats
    std::cout << BOLD << RED << "Threats Detected!" << RESET << std::endl;
    for (size_t i = 0; i < threats.size(); ++i) {
        const auto& threat = threats[i];
        std::cout << i + 1 << ". ID: " << threat.detectionId
                  << ", To: " << threat.targetName
                  << ", Distance: " << static_cast<int>(threat.distanceToTarget)
                  << ", Speed: " << static_cast<int>(threat.calculatedSpeed) << " m/s" << std::endl;
    }

    // Handle threat interception
    int interceptChoice = getChoice("\nChoose a threat to intercept (by number), or 0 to cancel: ", 
                                   0, threats.size());
    
    if (interceptChoice != 0) {
        const ThreatReport& chosenThreat = threats[interceptChoice - 1];
        int enemyMissileId = controller.interceptThreat(chosenThreat);

        if (removeEnemyMissileById(enemyMissiles, enemyMissileId)) {
            std::cout << GREEN << "\nEnemy missile #" << enemyMissileId 
                      << " has been intercepted and removed from the system." << RESET << std::endl;
        } else {
            std::cout << RED << "\nError: Could not find and remove enemy missile #" 
                      << enemyMissileId << "." << RESET << std::endl;
        }
    }
}

/**
 * Displays the main menu
 */
void displayMenu() {
    std::cout << "\nMenu:\n";
    std::cout << "1. List Missiles\n";
    std::cout << "2. Launch Missile\n";
    std::cout << "3. Detect Incoming Threats\n";
    std::cout << "4. Exit\n";
}

/**
 * Initializes system data including missiles, targets, and enemy missiles
 * @param controller Reference to missile controller to populate
 * @param enemyMissiles Reference to enemy missile vector to populate
 * @param targets Reference to targets vector
 */
void initializeSystem(MissileController& controller, 
                     std::vector<EnemyMissile>& enemyMissiles,
                     const std::vector<Target>& targets) {
    int missileId = 1;
    
    // Launch pad positions
    const Position launchPadA = {100.0, 50.0, 0.0};
    const Position launchPadB = {200.0, 75.0, 0.0};
    
    // Missile configurations
    const std::vector<MissileConfig> configs = {
        {100, "Patriot", 80.0, launchPadA},
        {100, "Patriot", 80.0, launchPadA},
        {200, "Tomahawk", 100.0, launchPadB},
        {50, "Stinger", 120.0, launchPadB},
        {150, "Javelin", 90.0, launchPadA}
    };

    // Add missiles to controller
    for (const auto& config : configs) {
        controller.addMissile(Missile(
            missileId++,
            config.damage,
            config.name,
            config.speed,
            config.position
        ));
    }

    // Initialize enemy missiles
    enemyMissiles.push_back(EnemyMissile(101, {5000.0, 3000.0, 0.0}, targets[0].position, 150.0));
    enemyMissiles.push_back(EnemyMissile(102, {6000.0, 4000.0, 0.0}, targets[1].position, 180.0));
}

int main() {
    std::cout << BOLD << GREEN << "\nNORAD Missile System Engaged" << RESET << "\n";
    
    // System initialization
    MissileController controller;
    std::vector<EnemyMissile> enemyMissiles;
    
    const std::vector<Target> targets = {
        {"Pyongyang", {127.5, 39.0, 0.0}},
        {"Moscow", {37.6, 55.7, 0.0}},
        {"Beijing", {116.4, 39.9, 0.0}}
    };
    
    initializeSystem(controller, enemyMissiles, targets);
    DetectionSystem radar(enemyMissiles, targets);

    // Main application loop
    bool running = true;
    while (running) {
        displayMenu();
        MenuOption choice = static_cast<MenuOption>(getChoice("\nChoose an option: ", 1, 4));

        switch (choice) {
            case LIST:
                controller.printAllStatuses();
                break;
                
            case LAUNCH:
                handleLaunchMissile(controller, targets);
                break;
                
            case DETECT:
                handleThreatDetection(controller, enemyMissiles, radar);
                break;
                
            case EXIT:
                running = false;
                std::cout << BOLD << GREEN << "System shutdown complete." << RESET << std::endl;
                break;
                
            default:
                std::cout << RED << "Invalid option." << RESET << "\n";
                break;
        }
    }
    
    return 0;
}#include "detection_system.h"
#include <cmath>
#include "target.h"
#include "enemy_missile.h"
#include <iostream>

DetectionSystem::DetectionSystem(const std::vector<EnemyMissile> &enemyMissiles, const std::vector<Target> &targets)
    : enemyMissiles(enemyMissiles), targets(targets), detectionIdCounter(0) {}

std::vector<ThreatReport> DetectionSystem::scanForThreats()
{
    std::vector<ThreatReport> currentThreats;

    // Loop through all our detected enemy missiles
    for (const auto &enemy : enemyMissiles)
    {

        // Get the enemy missile's intended target position
        Position enemyTargetPos = enemy.getTargetPosition();
        //   std::cout << "Enemy target pos: {" << enemyTargetPos.x
        //              << ", " << enemyTargetPos.y
        //              << ", " << enemyTargetPos.z << "}" << std::endl;
        // Find the actual Target object that matches this position
        // This is a simplified way to find the target's name
        std::string targetName = "Unknown";
        for (const auto &target : targets)
        {
            if (target.position.x == enemyTargetPos.x &&
                target.position.y == enemyTargetPos.y &&
                target.position.z == enemyTargetPos.z)
            {
                targetName = target.name;
                break;
            }
        }

        // Calculate the 3D distance between the enemy missile and its intended target
        double dx = enemy.getCurrentPosition().x - enemyTargetPos.x;
        double dy = enemy.getCurrentPosition().y - enemyTargetPos.y;
        double dz = enemy.getCurrentPosition().z - enemyTargetPos.z;
        double distance = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2) + std::pow(dz, 2));

        const double THREAT_RANGE = 10000.0;
        if (distance < THREAT_RANGE)
        {
            ThreatReport threat;
            threat.detectionId = enemy.getId();
            threat.enemyId = enemy.getId();
            threat.enemyName = "Unidentified Threat";
            threat.targetName = targetName;
            threat.distanceToTarget = distance;
            threat.calculatedSpeed = enemy.getSpeed();
            threat.enemyPosition = enemy.getCurrentPosition();

            currentThreats.push_back(threat);
        }
    }
    return currentThreats;
}#include <iostream>
#include <vector>
#include <string>
#include <limits>
#include <thread>
#include <chrono>
#include <iomanip>
#include <cstdlib>
#include "missile_controller.h"
#include "enemy_missile.h"
#include "detection_system.h"
#include "target.h"

// Color constants for terminal output
#define RESET "\033[0m"
#define BOLD "\033[1m"
#define GREEN "\033[32m"
#define YELLOW "\033[33m"
#define CYAN "\033[36m"
#define RED "\033[31m"
#define BLUE "\033[34m"
#define MAGENTA "\033[35m"

// Configuration structure for missile initialization
struct MissileConfig
{
    int damage;
    std::string name;
    double speed;
    Position position;
};

// Menu options enum for better code readability
enum MenuOption
{
    LIST = 1,
    LAUNCH = 2,
    DETECT = 3,
    AUTO_INTERCEPT = 4, // New option
    LIVE_VIEW = 5,
    EXIT = 6
};
// Clear screen function
void clearScreen()
{
#ifdef _WIN32
    system("cls");
#else
    system("clear");
#endif
}

// Move cursor to top-left
void resetCursor()
{
    std::cout << "\033[H";
}

/**
 * Gets validated integer input from user within specified range
 */
int getChoice(const std::string &prompt, int min, int max)
{
    int choice;
    while (true)
    {
        std::cout << prompt;
        std::cin >> choice;

        if (std::cin.fail() || choice < min || choice > max)
        {
            std::cout << RED << "Invalid option. Please enter a number between "
                      << min << " and " << max << "." << RESET << "\n";
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
        else
        {
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            return choice;
        }
    }
}

/**
 * Removes an enemy missile from the vector by ID
 */
bool removeEnemyMissileById(std::vector<EnemyMissile> &enemies, int id)
{
    for (auto it = enemies.begin(); it != enemies.end(); ++it)
    {
        if (it->getId() == id)
        {
            enemies.erase(it);
            return true;
        }
    }
    return false;
}

/**
 * Display live battlefield view
 */
void displayLiveBattlefield(const MissileController &controller,
                            const std::vector<EnemyMissile> &enemyMissiles,
                            const std::vector<Target> &targets,
                            const std::vector<ThreatReport> &threats)
{
    clearScreen();

    // Header
    std::cout << BOLD << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;
    std::cout << BOLD << CYAN << "                    MISSILE DEFENSE COMMAND CENTER             " << RESET << std::endl;
    std::cout << BOLD << CYAN << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << RESET << std::endl;

    // System status
    auto now = std::chrono::system_clock::now();
    auto time_t = std::chrono::system_clock::to_time_t(now);
    std::cout << YELLOW << "Time: " << std::put_time(std::localtime(&time_t), "%H:%M:%S")
              << "    Status: " << GREEN << "OPERATIONAL" << RESET << std::endl;
    std::cout << std::endl;

    // Threats section
    if (!threats.empty())
    {
        std::cout << BOLD << RED << "ðŸš¨ ACTIVE THREATS: " << threats.size() << RESET << std::endl;
        for (const auto &threat : threats)
        {
            std::cout << RED << "  â–¶ Threat #" << threat.detectionId
                      << " â†’ " << threat.targetName
                      << " (Distance: " << static_cast<int>(threat.distanceToTarget) << "km)"
                      << RESET << std::endl;
        }
    }
    else
    {
        std::cout << GREEN << "âœ… NO THREATS DETECTED" << RESET << std::endl;
    }
    std::cout << std::endl;

    // Enemy missiles
    std::cout << BOLD << MAGENTA << "ðŸŽ¯ ENEMY MISSILES:" << RESET << std::endl;
    if (enemyMissiles.empty())
    {
        std::cout << GREEN << "  None detected" << RESET << std::endl;
    }
    else
    {
        for (const auto &enemy : enemyMissiles)
        {
            Position pos = enemy.getCurrentPosition();
            Position target = enemy.getTargetPosition();
            std::cout << RED << "  â–¶ ID:" << enemy.getId()
                      << " Pos:(" << static_cast<int>(pos.x) << "," << static_cast<int>(pos.y) << ")"
                      << " â†’ (" << static_cast<int>(target.x) << "," << static_cast<int>(target.y) << ")"
                      << " Speed:" << static_cast<int>(enemy.getSpeed()) << "m/s"
                      << RESET << std::endl;
        }
    }
    std::cout << std::endl;

    // Our missiles
    std::cout << BOLD << BLUE << "ðŸš€ OUR MISSILES:" << RESET << std::endl;
    controller.printAllStatuses();
    std::cout << std::endl;

    // Targets
    std::cout << BOLD << YELLOW << "ðŸ™ï¸  PROTECTED TARGETS:" << RESET << std::endl;
    for (const auto &target : targets)
    {
        std::cout << YELLOW << "  â–¶ " << target.name
                  << " (" << target.position.x << "," << target.position.y << ")"
                  << RESET << std::endl;
    }
    std::cout << std::endl;

    std::cout << CYAN << "Press Ctrl+C to return to menu..." << RESET << std::endl;
}

// Update your live view to include auto-intercept
// FIXED: Updated live view
void runLiveView(MissileController &controller,
                 std::vector<EnemyMissile> &enemyMissiles,
                 const std::vector<Target> &targets,
                 DetectionSystem &radar)
{

    clearScreen();
    std::cout << BOLD << GREEN << "Entering Live View Mode..." << RESET << std::endl;
    if (controller.isAutoInterceptEnabled())
    {
        std::cout << BOLD << MAGENTA << "ðŸ¤– Auto-intercept is ACTIVE" << RESET << std::endl;
    }
    std::cout << "Press Ctrl+C to exit" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));

    try
    {
        while (true)
        {
            // Update enemy missile positions
            for (auto &enemy : enemyMissiles)
            {
                enemy.move();
            }

            // Scan for threats
            std::vector<ThreatReport> threats = radar.scanForThreats();

            // AUTO-INTERCEPT IN LIVE VIEW (FIXED)
            if (!threats.empty() && controller.isAutoInterceptEnabled())
            {
                std::vector<int> interceptedIds = controller.autoInterceptThreats(threats);

                // Remove only the actually intercepted missiles
                for (int enemyId : interceptedIds)
                {
                    removeEnemyMissileById(enemyMissiles, enemyId);
                }
            }

            // Rescan after potential interceptions
            threats = radar.scanForThreats();

            // Display the battlefield
            displayLiveBattlefield(controller, enemyMissiles, targets, threats);

            std::this_thread::sleep_for(std::chrono::milliseconds(1500));
        }
    }
    catch (...)
    {
        clearScreen();
        std::cout << YELLOW << "Exiting live view..." << RESET << std::endl;
    }
}
/**
 * Handles the missile launch process including target selection
 */
void handleLaunchMissile(MissileController &controller, const std::vector<Target> &targets)
{
    controller.printAllStatuses();

    int missileIdToLaunch = getChoice("\nEnter the ID of the missile to launch: ", 1, 999);
    Missile *missileToLaunch = controller.getMissileById(missileIdToLaunch);

    if (missileToLaunch)
    {
        std::cout << "\nAvailable Targets:\n";
        for (size_t i = 0; i < targets.size(); ++i)
        {
            std::cout << i + 1 << ". " << targets[i].name << "\n";
        }

        int targetChoice = getChoice("\nChoose a target (by number): ", 1, targets.size());
        const Position &chosenTarget = targets[targetChoice - 1].position;
        controller.launchMissile(*missileToLaunch, chosenTarget);
    }
    else
    {
        std::cout << RED << "Missile with ID " << missileIdToLaunch << " not found." << RESET << "\n";
    }
}

/**
 * Handles threat detection and interception process
 */
void handleThreatDetection(MissileController &controller,
                           std::vector<EnemyMissile> &enemyMissiles,
                           DetectionSystem &radar)
{
    std::cout << BOLD << CYAN << "Scanning for threats..." << RESET << std::endl;

    // Update enemy missile positions
    for (auto &enemy : enemyMissiles)
    {
        enemy.move();
    }

    std::vector<ThreatReport> threats = radar.scanForThreats();

    if (threats.empty())
    {
        std::cout << GREEN << "No threats detected." << RESET << std::endl;
        return;
    }

    // AUTO-INTERCEPT CHECK (FIXED)
    if (controller.isAutoInterceptEnabled())
    {
        std::cout << YELLOW << "Auto-intercept system analyzing threats..." << RESET << std::endl;
        std::vector<int> interceptedEnemyIds = controller.autoInterceptThreats(threats);

        // Remove ONLY the actually intercepted enemy missiles
        for (int enemyId : interceptedEnemyIds)
        {
            if (removeEnemyMissileById(enemyMissiles, enemyId))
            {
                std::cout << GREEN << "âœ… Enemy missile #" << enemyId
                          << " successfully auto-intercepted and removed" << RESET << std::endl;
            }
            else
            {
                std::cout << RED << "âŒ Failed to remove enemy missile #" << enemyId << RESET << std::endl;
            }
        }

        // If auto-intercept handled some threats, update the threats list for display
        if (!interceptedEnemyIds.empty())
        {
            // Remove intercepted threats from display list
            threats.erase(
                std::remove_if(threats.begin(), threats.end(),
                               [&interceptedEnemyIds](const ThreatReport &threat)
                               {
                                   return std::find(interceptedEnemyIds.begin(), interceptedEnemyIds.end(),
                                                    threat.enemyId) != interceptedEnemyIds.end();
                               }),
                threats.end());

            // Rescan for remaining threats after position updates
            threats = radar.scanForThreats();
        }
    }

    // Display remaining threats for manual handling
    if (!threats.empty())
    {
        std::cout << BOLD << RED << "Remaining Threats Detected!" << RESET << std::endl;
        for (size_t i = 0; i < threats.size(); ++i)
        {
            const auto &threat = threats[i];
            std::cout << i + 1 << ". ID: " << threat.detectionId
                      << ", Enemy: " << threat.enemyId
                      << ", To: " << threat.targetName
                      << ", Distance: " << static_cast<int>(threat.distanceToTarget)
                      << ", Speed: " << static_cast<int>(threat.calculatedSpeed) << " m/s" << std::endl;
        }

        int interceptChoice = getChoice("\nChoose a threat to manually intercept (by number), or 0 to cancel: ",
                                        0, threats.size());

        if (interceptChoice != 0)
        {
            const ThreatReport &chosenThreat = threats[interceptChoice - 1];
            int enemyMissileId = controller.interceptThreat(chosenThreat);

            if (removeEnemyMissileById(enemyMissiles, enemyMissileId))
            {
                std::cout << GREEN << "\nâœ… Enemy missile #" << enemyMissileId
                          << " has been manually intercepted and removed." << RESET << std::endl;
            }
        }
    }
    else if (controller.isAutoInterceptEnabled())
    {
        std::cout << GREEN << "All detected threats have been auto-intercepted!" << RESET << std::endl;
    }
}
/**
 * Displays the main menu
 */
void displayMenu()
{
    std::cout << "\nMenu:\n";
    std::cout << "1. List Missiles\n";
    std::cout << "2. Launch Missile\n";
    std::cout << "3. Detect Incoming Threats\n";
    std::cout << "4. ðŸ¤– Auto-Intercept Settings\n"; // New option
    std::cout << "5. ðŸ”´ Live Battlefield View\n";
    std::cout << "6. Exit\n";
}

void handleAutoInterceptMenu(MissileController &controller)
{
    while (true)
    {
        std::cout << "\n"
                  << BOLD << CYAN << "Auto-Intercept Configuration:" << RESET << std::endl;
        controller.printAutoInterceptStatus();

        std::cout << "\n1. Toggle Auto-Intercept\n";
        std::cout << "2. Set Distance Threshold\n";
        std::cout << "3. Set Max Auto-Intercept Missiles\n";
        std::cout << "4. Reset Usage Counter\n";
        std::cout << "5. Back to Main Menu\n";

        int choice = getChoice("\nChoose option: ", 1, 5);

        switch (choice)
        {
        case 1:
        {
            bool current = controller.isAutoInterceptEnabled();
            controller.setAutoIntercept(!current);
            break;
        }
        case 2:
        {
            std::cout << "Enter new threshold distance (km): ";
            double threshold;
            std::cin >> threshold;
            if (threshold > 0)
            {
                controller.setAutoInterceptThreshold(threshold);
            }
            else
            {
                std::cout << RED << "Invalid threshold" << RESET << std::endl;
            }
            break;
        }
        case 3:
        {
            int maxMissiles = getChoice("Enter max auto-intercept missiles: ", 1, 10);
            controller.setMaxAutoInterceptMissiles(maxMissiles);
            break;
        }
        case 4:
        {
            // Reset the usage counter (you'd need to add this method)
            std::cout << GREEN << "Usage counter reset" << RESET << std::endl;
            break;
        }
        case 5:
            return; // Back to main menu
        }
    }
}

/**
 * Initializes system data including missiles, targets, and enemy missiles
 */
void initializeSystem(MissileController &controller,
                      std::vector<EnemyMissile> &enemyMissiles,
                      const std::vector<Target> &targets)
{
    int missileId = 1;

    // Launch pad positions
    const Position launchPadA = {100.0, 50.0, 0.0};
    const Position launchPadB = {200.0, 75.0, 0.0};

    // Missile configurations
    const std::vector<MissileConfig> configs = {
        {100, "Patriot", 80.0, launchPadA},
        {100, "Patriot", 80.0, launchPadA},
        {200, "Tomahawk", 100.0, launchPadB},
        {50, "Stinger", 120.0, launchPadB},
        {150, "Javelin", 90.0, launchPadA}};

    // Add missiles to controller
    for (const auto &config : configs)
    {
        controller.addMissile(Missile(
            missileId++,
            config.damage,
            config.name,
            config.speed,
            config.position));
    }

    // Initialize enemy missiles with more interesting movement
    enemyMissiles.push_back(EnemyMissile(101, {5000.0, 3000.0, 0.0}, targets[0].position, 50.0));
    enemyMissiles.push_back(EnemyMissile(102, {6000.0, 4000.0, 0.0}, targets[1].position, 75.0));
    enemyMissiles.push_back(EnemyMissile(103, {4500.0, 2500.0, 0.0}, targets[2].position, 60.0));
}

int main()
{
    std::cout << BOLD << GREEN << "\nNORAD Missile System Engaged" << RESET << "\n";

    // System initialization
    MissileController controller;
    std::vector<EnemyMissile> enemyMissiles;

    const std::vector<Target> usTargets = {
        {"New York", {-74.0, 40.7, 0.0}},
        {"Washington DC", {-77.0, 38.9, 0.0}},
        {"Los Angeles", {-118.2, 34.0, 0.0}}};

    const std::vector<Target> retaliationTargets = {
        {"Pyongyang", {127.5, 39.0, 0.0}},
        {"Moscow", {37.6, 55.7, 0.0}},
        {"Beijing", {116.4, 39.9, 0.0}}};

    initializeSystem(controller, enemyMissiles, usTargets);
    DetectionSystem radar(enemyMissiles, usTargets);

    // Main application loop
    bool running = true;
    while (running)
    {
        displayMenu();
        MenuOption choice = static_cast<MenuOption>(getChoice("\nChoose an option: ", LIST, EXIT));

        switch (choice)
        {
        case LIST:
            controller.printAllStatuses();
            break;

        case LAUNCH:
            handleLaunchMissile(controller, retaliationTargets);
            break;

        case DETECT:
            handleThreatDetection(controller, enemyMissiles, radar);
            break;

        case AUTO_INTERCEPT: // NEW CASE
            handleAutoInterceptMenu(controller);
            break;

        case LIVE_VIEW:
            runLiveView(controller, enemyMissiles, usTargets, radar);
            break;

        case EXIT:
            running = false;
            std::cout << BOLD << GREEN << "System shutdown complete." << RESET << std::endl;
            break;
        }
    }

    return 0;
}#include "missile.h"
#include <thread> // Required for std::this_thread::sleep_for
#include <chrono> // Required for std::chrono::milliseconds
#include <cmath>  // Required for std::sqrt
#include "position.h"
// This is the full definition of the constructor
Missile::Missile(int id, int damage, std::string missileName, double missileSpeed, Position startPosition)
    : id(id),
      damageStrength(damage),
      name(missileName),
      speed(missileSpeed),
      currentPosition(startPosition),
      isLaunched(false)
{
    // The body of the constructor is here.
    // All initialization is done in the initializer list
}

void Missile::move(double dx, double dy, double dz)
{
    currentPosition.x += dx;
    currentPosition.y += dy;
    currentPosition.z += dz;
}

void Missile::printStatus() const
{
    std::cout << "Missile #" << id << " (" << name << ") at ("
              << currentPosition.x << ", "
              << currentPosition.y << ", "
              << currentPosition.z << ")\n";
}

// --- Implement the new getter methods ---
int Missile::getId() const
{
    return id;
}

std::string Missile::getName() const
{
    return name;
}

double Missile::getSpeed() const
{
    return speed;
}

Position Missile::getCurrentPosition() const
{
    return currentPosition;
}

void Missile::triggerLaunch(const Position &target)
{
    if (isLaunched)
    {
        std::cout << "\033[31mMissile " << getName() << " (ID #" << getId() << ") is already launched!\033[0m" << std::endl;
        return;
    }

    isLaunched = true;
    std::cout << "\033[36m-- Launch sequence initiated for " << getName() << " --\033[0m" << std::endl;

    double maxAltitude = 500.0;
    Position initialPosition = currentPosition;

    int steps = 20;

    // Calculate total distance for a more meaningful progress bar
    double dxTotal = target.x - initialPosition.x;
    double dyTotal = target.y - initialPosition.y;
    double dzTotal = target.z - initialPosition.z;
    double totalDistance = std::sqrt(dxTotal * dxTotal + dyTotal * dyTotal + dzTotal * dzTotal);

    for (int i = 0; i <= steps; ++i)
    {
        double t = static_cast<double>(i) / steps;

        currentPosition.x = initialPosition.x + t * dxTotal;
        currentPosition.y = initialPosition.y + t * dyTotal;
        currentPosition.z = initialPosition.z + (t * (1.0 - t)) * maxAltitude * 4;

        // Use a progress indicator and colored output for the path
        double currentDistance = std::sqrt(
            std::pow(currentPosition.x - initialPosition.x, 2) +
            std::pow(currentPosition.y - initialPosition.y, 2) +
            std::pow(currentPosition.z - initialPosition.z, 2));

        std::cout << "\r\033[33m[ \033[0m"
                  << std::string(i, '#') << std::string(steps - i, ' ')
                  << "\033[33m ] " << static_cast<int>(t * 100) << "% "
                  << "pos: (" << static_cast<int>(currentPosition.x) << ", "
                  << static_cast<int>(currentPosition.y) << ", " << static_cast<int>(currentPosition.z) << ")\033[0m"
                  << std::flush;

        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }

    // Ensure final output is on a new line
    std::cout << std::endl;

    // Final position message
    currentPosition = target;
    std::cout << "\033[1;32m" << getName() << " (ID #" << getId() << ") has reached its target!\033[0m" << std::endl;
}